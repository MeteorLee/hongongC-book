# 혼자 공부하는 C언어

![혼자 공부하는 C언어](https://github.com/user-attachments/assets/b8e78901-b965-414f-8863-2b8f747233f4)

[한빛 미디어 - 혼자 공부하는 C언어](https://hongong.hanbit.co.kr/c%EC%96%B8%EC%96%B4/)

## 책 선정 이유

- 프로그래밍 공부를 시작한 이래 C언어를 제대로 공부해본 적이 없기에 책을 선정하여 공부하고자 함
- 소유하고 있는 C언어 서적 중 가장 깔끔해보여서 선택함

## 공부 목적 및 계획

- C언어의 전반적인 문법 습득
- C언어의 기본적인 지식 습득
- 모르는 지식 위주로 정리할 예정(알고 있는 초급 프로그래밍 내용은 생략 또는 간략하게 훑을 예정)

## 사용 도구

- GitHub
- GitKraken
- Git
- Visual Studio 2022
- ChatGPT
- DeepSeek

## 기간

2025.02.03 ~ 2025.02.07 예정(수정 가능)

# 목차

<details>
  <summary><strong>📖 바로가기</strong></summary>

- [혼자 공부하는 C언어](#혼자-공부하는-c언어)
  - [책 선정 이유](#책-선정-이유)
  - [공부 목적 및 계획](#공부-목적-및-계획)
  - [사용 도구](#사용-도구)
  - [기간](#기간)
- [목차](#목차)
- [01 프로그램 만들기](#01-프로그램-만들기)
  - [01-1 프로그램과 C 언어](#01-1-프로그램과-c-언어)
    - [📌 핵심 개념](#-핵심-개념)
  - [01-2 컴파일과 컴파일러 사용법](#01-2-컴파일과-컴파일러-사용법)
    - [📌 핵심 개념](#-핵심-개념-1)
    - [💻 중요 코드 및 예제](#-중요-코드-및-예제)
  - [리뷰](#리뷰)
- [02 상수와 데이터 출력](#02-상수와-데이터-출력)
  - [02-1 C 프로그램의 구조와 데이터 출력 방법](#02-1-c-프로그램의-구조와-데이터-출력-방법)
    - [📌 핵심 개념](#-핵심-개념-2)
    - [💻 코드 및 예제](#-코드-및-예제)
      - [제어 문자](#제어-문자)
      - [변환 문자](#변환-문자)
  - [02-2 상수와 데이터 표현 방법](#02-2-상수와-데이터-표현-방법)
    - [📌 핵심 개념](#-핵심-개념-3)
    - [💻 코드 및 예제](#-코드-및-예제-1)
      - [실수 상수 표현](#실수-상수-표현)
    - [🎯 배운 점 \& 인사이트](#-배운-점--인사이트)
      - [컴퓨터가 컴파일이 필요한 이유](#컴퓨터가-컴파일이-필요한-이유)
      - [보수](#보수)
      - [정수 상수의 음수 형태](#정수-상수의-음수-형태)
      - [실수 상수의 오차](#실수-상수의-오차)
      - [실수 상수의 연산에서의 오류](#실수-상수의-연산에서의-오류)
      - [Decimal은 어떻게?](#decimal은-어떻게)
  - [리뷰](#리뷰-1)
- [03 변수와 데이터 입력](#03-변수와-데이터-입력)
  - [변수](#변수)
  - [데이터 입력](#데이터-입력)
- [04 연산자](#04-연산자)
  - [산술 연산자, 관계 연산자, 논리 연산자](#산술-연산자-관계-연산자-논리-연산자)
  - [그 외 유용한 연산자](#그-외-유용한-연산자)
- [05 선택문](#05-선택문)
  - [if문](#if문)
  - [if문 활용과 switch ~ case문](#if문-활용과-switch--case문)
- [06 반복문](#06-반복문)
  - [while문, for문, do ~ while문](#while문-for문-do--while문)
  - [반복문 활용](#반복문-활용)
- [07 함수](#07-함수)
  - [함수의 작성과 사용](#함수의-작성과-사용)
  - [여러 가지 함수 유형](#여러-가지-함수-유형)
- [08 배열](#08-배열)
  - [배열의 선언과 사용](#배열의-선언과-사용)
  - [문자를 저장하는 배열](#문자를-저장하는-배열)
- [09 포인터](#09-포인터)
  - [포인터의 기본 개념](#포인터의-기본-개념)
  - [포인터 완전 정복을 위한 포인터 이해하기](#포인터-완전-정복을-위한-포인터-이해하기)
- [10 배열과 포인터](#10-배열과-포인터)
  - [배열과 포인터의 관계](#배열과-포인터의-관계)
  - [배열을 처리하는 함수](#배열을-처리하는-함수)
- [11 문자](#11-문자)
  - [아스키 코드 값과 문자 입출력 함수](#아스키-코드-값과-문자-입출력-함수)
  - [버퍼를 사용하는 입력 함수](#버퍼를-사용하는-입력-함수)
- [12 문자열](#12-문자열)
  - [문자열과 포인터](#문자열과-포인터)
  - [문자열 연산 함수](#문자열-연산-함수)
- [13 변수의 영역과 데이터 공유](#13-변수의-영역과-데이터-공유)
  - [변수 사용 영역](#변수-사용-영역)
  - [함수의 데이터 공유 방법](#함수의-데이터-공유-방법)
- [14 다차원 배열과 포인터 배열](#14-다차원-배열과-포인터-배열)
  - [다차원 배열](#다차원-배열)
  - [포인터 배열](#포인터-배열)
- [15 응용 포인터](#15-응용-포인터)
  - [이중 포인터와 배열 포인터](#이중-포인터와-배열-포인터)
  - [함수 포인터와 void 포인터](#함수-포인터와-void-포인터)
- [16 메모리 동적 할당](#16-메모리-동적-할당)
  - [동적 할당 함수](#동적-할당-함수)
  - [동적 할당 저장 공간의 활용](#동적-할당-저장-공간의-활용)
- [17 사용자 정의 자료형](#17-사용자-정의-자료형)
  - [구조체](#구조체)
  - [구조체 활용, 공용체, 열거형](#구조체-활용-공용체-열거형)
- [18 파일 입출력](#18-파일-입출력)
  - [파일 개방과 입출력](#파일-개방과-입출력)
  - [다양한 파일 입출력 함수](#다양한-파일-입출력-함수)
- [19 전처리와 분할 컴파일](#19-전처리와-분할-컴파일)
  - [전처리 지시자](#전처리-지시자)
  - [분할 컴파일](#분할-컴파일)

</details>


---


# 01 프로그램 만들기

- 프로그램, C언어란 무엇인가?
- 컴파일러를 내려받아 설치하는 방법
- 프로그램 코딩, 컴파일 및 실행

## 01-1 프로그램과 C 언어

### 📌 핵심 개념

- 프로그램 : 컴퓨터가 작업을 수행하도록 작성된 명령어들의 집합
- C언어 : 시스템 프로그래밍과 하드웨어와 유닉스 시스템에 사용하기 위해 만들어진 고급 프고르개밍 언어
- C언어 장점 
  - 시스템 프로그래밍이 가능 : 운영체제 개발 목적 언어이므로 하드웨어를 제어하는 시스템 프로그래밍이 가능
  - 이식성을 갖춤 : 표준을 지킨다면 다른 기종의 컴퓨터에서도 사용할 수 있는 프로그램을 만들 수 있다
  - 함수를 사용한 개별 프로그래밍 : 함수를 사용하여 기능별로 프로그래밍이 가능하므로 개발 과정, 유지보수에 도움이 된다
- C언어 단점
  - 플랫폼 종속적 : 플랫폼에 종속적으로 하나의 프로그램으로 다른 플랫폼에서 실행이 불가능하다(반대로 자바는 모든 플랫폼에서 JVM을 이용하여 하나의 프로그램으로 실행이 가능하다)

## 01-2 컴파일과 컴파일러 사용법

### 📌 핵심 개념

- 소스 코드 : 프로그래밍 언어로 작성된 파일로 프로그램의 설계도 역할을 하지만 아직 컴퓨터가 읽을 수 있는 기계어로 변환되지 않은 코드
- 기계어 : 컴퓨터가 실행할 수 있는 0과 1의 이진수로 된 언어로 가장 낮은 수준의 프로그래밍 언어
- 컴파일 : 소스 코드(고급 프로그래밍 언어)를 기계어나 바이트코드로 변환하는 과정으로 컴파일러를 통해 이루어진다
- 컴파일의 3단계
  - 1.전처리 : 컴파일 전에 소스 코드를 분석하여 필요한 처리를 한다(매크로 확장, 파일 포함(ex.#include) ...)
  - 2.컴파일 : 전처리가 끝난 파일을 CPU가 해석 가능한 명령어로 이루어진 기계어 파일인 목적 파일(Object file)로 변환
  - 3.링크 : 목적 파일에 startup code를 결합하고 목적 파일과 라이브러리를 결합하여 실행 가능한 파일로 만든다
- startup code : 프로그램 실행 전에 메모리, 하드웨어, 런타임 환경을 초기화하고 main() 함수를 호출하는 코드로 사용자가 직접 작성하는 경우는 매우 드물다

### 💻 중요 코드 및 예제

컴파일 : `ctrl` + `shift` + `B`
실행 : `ctrl` + `F5`

## 리뷰

- 기본적인 컴퓨터 프로그래밍에 대해서 설명한다. 내용이 깊지 않고 간결하기에 기본 개념에 대해 잘 알고 있는 나에게는 짧게 훑어볼 정도 였다
- Visual Studio 와 관련된 기본적인 사용법을 배우는데 내가 자주 사용하는 IDE는 아니지만 여러 IDE를 사용해봤기에 크게 어렵지는 않았다
- 컴파일 관련된 내용으로는 오랜만에 꼼꼼하게 보니 기억속에 사라진 내용이 많아 다시 채워 넣는다는 생각으로 공부했다

--- 

# 02 상수와 데이터 출력

 - C 프로그램의 구조 살펴보기
 - C 프로그램에서 값을 표현하는 방법과 결과를 화면하는 출력하는 방법
 - C 프로그램에서 컴퓨터 내부에 값이 저장되는 방식

## 02-1 C 프로그램의 구조와 데이터 출력 방법

### 📌 핵심 개념

- 함수 : 일정한 기능을 수행하는 코드의 단위
- main 함수 : 프로그램의 시작점으로 운영체제가 프로그램을 실행할 때 가장 먼저 호출하는 함수
- 제어 문자 : 텍스트 데이터에서 특수한 기능을 수행하는 문자로 화면에 출력되지 않고 형식이나 장치를 제어하는 데 사용
- 변환 문자 : 데이터를 특정 형식으로 출력, 입력할 때 사용하는 문자로 데이터 타입에 따라 다르다

### 💻 코드 및 예제

#### 제어 문자

```c
#include<stdio.h>

int main(void)
{
	printf("My\tFriend\n");
	// "My"를 출력학 탭 위치로 이동(\t) 후에 "friend"를 출력하고 줄 바꿈(\n)
	printf("Goot\bd\tchance\n"); // Good  chance
	// "goot"를 출력하고 한 칸 왼쪽으로 이동(\b)해 t를 d로 바꾸고 탭 위치로 이동(\t) 후에 "chance"를 출력하고 줄 바꿈(\n)
	printf("Cow\rW\a\n"); // Wow  
	// 맨 앞으로 이동(\r)해 C를 W로 바꾸고 벨소리(\a)를 내고 줄 바꿈(\n)

	return 0;
}
```

- 제어 문자로 커서를 이동 시키면 삽입이 아닌 수정의 개념으로 이미 작성된 문자를 수정함

|제어 문자|역할|설명|
|---|---|---|
|\n|개행|새로운 줄로 이동|
|\t|탭 |수평 탭으로 일정 간격으로 커서 이동|
|\r|캐리지 리턴|커서를 현재 줄의 맨 앞으로 이동|
|\b|백스페이스|커서를 한 칸 뒤로(왼쪽)   이동|
|\a|벨|경고음 발생|

#### 변환 문자

```C
#include<stdio.h>

int main(void)
{
	printf("%d\n", 10);
	printf("%lf\n", 3.4);		// lf 위치에 소수점 6자리 까지 출력
	printf("%.1lf\n", 3.455);	// lf 위치에 소수점 1자리 까지 출력(2번째 자리에서 반올림)
	printf("%.10lf\n", 3.455);	// 소수점 10자리 까지 출력

	printf("%d과 %d의 합은 %d입니다\n", 10, 20, 10 + 20);
	printf("%.1lf - %.1lf = %.1lf\n", 3.4, 1.2, 3.4 - 1.2);
}
```

- 기본적으로 실수는 소수점 6자리 까지 표현한다
- 자릿수를 맞추고 싶다면 %. (자릿수) lf 를 이용한다

|변환 문자|데이터 타입|
|---|---|
|%d|정수|
|%lf|실수|
|%c|문자|
|%s|문자열|

## 02-2 상수와 데이터 표현 방법

### 📌 핵심 개념

- 상수 : 프로그램 실행 중 변경되지 않는 고정된 값
- 정규화 표기법 : 지수 형태의 실수를 표현할 때 소수점 앞에 0이 아닌 유효 숫자 한 자리를 사용하는 표기법(ex. 3.14e-5)
- 아스키 코드 : 컴퓨터에서 문자를 표현하기 위한 표준 코드 체계로 7비트를 이용하여 128개의 문자를 표현한다(ex. A:65, a:97, 0:48)
- 부동 소수점 : 컴퓨터에서 넓은 범위의 실수를 표현하기 위해 자주 사용되는 방식으로 지수, 가수, 부호 비트의 3가지로 이루어져 있다   
  하지만 근사치를 표현하기에 정확한 계산이 필요한 경우에는 다른 방식이 요구 된다

### 💻 코드 및 예제

#### 실수 상수 표현

```C
#include<stdio.h>

int main(void)
{
	printf("%.1lf\n", 1e6);				// 지수 형태의 실수를 소수점 형태로 출력
	printf("%.7lf\n", 3.14e-5);			// 소수점 이하 7자리 까지 출력
	printf("%le\n", 0.0000314);			// 소수점 형태의 실수를 지수 형태로 출력
	printf("%.2le\n|", 0.0000314);		// 지수 형태의 소수점 이하 2자리까지 출력

	return 0;
}
```

- 실수 상수는 소수점 형태, 지수 형태 2가지로 표현이 가능함

|변환 문자|형태|예시|
|---|---|--|
|%lf|소수점 형태|0.0000314|
|%le|지수 형태|3.14e-5|

### 🎯 배운 점 & 인사이트

#### 컴퓨터가 컴파일이 필요한 이유

프로그램이 컴파일 과정없이 실행이 불가능 한 이유는 `10 + 20`의 간단한 연산에서도 **컴퓨터는 `10` `+` `20`의 3가지 문자데이터**로 밖에 이해가 불가능하기 때문이다.  
따라서 컴파일 과정을 통해 `10`과 `20`은 정수의 데이터로 `+` 연산자는 명령어로 변환하는 과정(컴파일)이 필요하다

#### 보수

보수란 어떤 수를 기준으로 하여 차이를 나타내는 값이다. 여기서 기수보수, 감소 소부로 나뉜다.

- 기수 보수 : 어떤 수를 기수(진법의 밑수) 에서 뺀 값(거듭제곱에서 뺀 값)
  - 10의 보수 : 123의 10의 보수는 10^3 - 123 = 1000 - 123 = 877
  - 2의 보수 : 5의 2의 보수는 2^4 - 5 = 16 - 5 = 11

- 감소 보수 : 어떤 수를 (기수-1)의 거듭제곱에서 뺀값(어떤 수를 기수로만 이루어진 숫자에서 뺀 값)
  - 9의 보수 : 123의 9의 보수는 999 - 123 = 876
  - 1의 보수(비트에서 이루어짐) : 5의 1의 보수는 1111 - 0101(5) = 1010(10)

#### 정수 상수의 음수 형태

음수의 정수는 2의 보수로 바꾸어 처리한다. 보수는 위에서 조금 더 자세하게 설명했다.
보스를 사용하는 이유는 특별한 변환 과정 없이 음수와 양수를 더할 수 있기 때문이다.

- 2의 보수를 만드는 방법 : 보수는 2의 거듭 제곱에서 해당 값을 빼면 만들 수 있지만 비트의 경우 모든 비트의 0과 1을 바꾼 상태에서 1을 더하여 만들 수 있다.

- 특정 값 a의 2의 보수를 구한다면 `2^33 - a = b`로 b가 나온다.  
이를 바꾸어 연산하면 `a + b = 2^33`이 된다.  
따라서 특별한 변환 과정 없이 가장 높은 자리의 비트의 다음 자리로 1이 넘어가게 되며 컴퓨터에서는 다음 자리가 없기에 1이 없어진다.  
이를 통해 모든 비트가 0이 되므로 결과 값이 `0`이 된다.

```
+10     00000000 00000000 00000000 00001010
-10     11111111 11111111 11111111 11110110
  0 (1) 00000000 00000000 00000000 00000000
```

#### 실수 상수의 오차

컴퓨터에서 실수를 부동 소수점으로 표현, 저장하는 것을 주로 사용한다.   
여기서 생기는 문제점은 10진수로 이루어진 실수를 2진수로 완벽하게 표기하기 어렵다.

0.1을 2진법으로 표현한다면
```
0.1 = 0.0001(1/16) + 0.00001(1/32) + ...
0.1 = 0.00625 + 0.003125 + ...

0.1 = 0.0001100110011...(2) - 무한 소수
```

#### 실수 상수의 연산에서의 오류

위의 내용대로 컴퓨터는 실수를 부동 소수점을 이용한 근사치로 저장하기에 실수 끼리의 연산 과정에서 문제가 발생한다.

- 0.1 + 0.2 = 0.3?
  
```
1. 0.1과 0.2의 2진법 표현
0.1과 0.2는 2진법으로 무한 순환 소수입니다. 컴퓨터는 이들을 정확히 저장할 수 없기 때문에 근사치로 저장합니다.

0.1의 2진법 표현
0.1(10) = 0.000110011001100110011001100110011001100110011001100110011001...(2)
컴퓨터는 이 값을 근사치로 저장합니다.

0.2의 2진법 표현
0.2(10) = 0.001100110011001100110011001100110011001100110011001100110011...(2)
이 값도 근사치로 저장됩니다.


2. 컴퓨터에서의 저장 방식
컴퓨터는 부동소수점 방식으로 실수를 저장합니다. 예를 들어, 64비트 배정밀도(double precision)에서는

가수(Mantissa): 52비트
지수(Exponent): 11비트
부호(Sign): 1비트

0.1의 부동소수점 표현
부호: 0 (양수)
지수: 01111111011 (2진수)
가수: 1001100110011001100110011001100110011001100110011010 (52비트)

0.2의 부동소수점 표현
부호: 0 (양수)
지수: 01111111100 (2진수)
가수: 1001100110011001100110011001100110011001100110011010 (52비트)


3. 0.1 + 0.2의 계산 과정
0.1과 0.2를 더할 때, 컴퓨터는 다음과 같은 과정을 거칩니다.

1단계: 지수 맞추기
두 수의 지수를 동일하게 맞춥니다.

0.1의 지수: 01111111011 (2진수) = -4 (10진수)
0.2의 지수: 01111111100 (2진수) = -3 (10진수)
0.1의 지수를 -3으로 맞추기 위해, 가수를 오른쪽으로 한 비트 시프트(shift)합니다.
0.1 = 1.1001100110011001100110011001100110011001100110011010 × 2⁻⁴
→
0.1 = 0.11001100110011001100110011001100110011001100110011010 × 2⁻³

2단계: 가수 더하기
두 수의 가수를 더합니다.
0.11001100110011001100110011001100110011001100110011010(2)
+
1.1001100110011001100110011001100110011001100110011010(2)
10.01100110011001100110011001100110011001100110011001110(2)

3단계: 정규화
결과를 정규화합니다. 정규화는 가수의 정수 부분이 1이 되도록 조정하는 과정입니다.
10.01100110011001100110011001100110011001100110011001110(2)
1.001100110011001100110011001100110011001100110011001110(2) × 2¹

4단계: 반올림
가수 필드는 52비트로 제한되어 있으므로, 53번째 비트에서 반올림합니다.
1.001100110011001100110011001100110011001100110011001110(2)
→
1.0011001100110011001100110011001100110011001100110100(2)

5단계: 최종 결과
최종 결과는 다음과 같습니다.
1.0011001100110011001100110011001100110011001100110100(2) × 2¹

이 값을 10진수로 변환하면
0.3000000000000000444089209850062616169452667236328125(10)


4. 왜 오차가 발생하나요?
0.1과 0.2는 2진법으로 정확히 표현할 수 없는 무한 순환 소수입니다.
컴퓨터는 이들을 근사치로 저장하기 때문에, 계산 과정에서 오차가 누적됩니다.
반올림 과정에서도 오차가 발생할 수 있습니다.
```

문제를 해결하기 위해서는 다른 방식으로 실수 데이터를 저장하는 것이 좋다.(Decimal)

#### Decimal은 어떻게?

실수 데이터를 근사가 아닌 10진법으로 저장하기 위해서는 부호 비트와 2가지의 정수 형태로 저장한다.

1. 부호 : 양수 음수
2. 정수 : 모든 자릿수를 정수로 저장
3. 소수점 위치 : 소수점이 몇 번째 자리인지 정수로 저장

**`Decimal = 정수 * 10^소수점 이하 자릿수`**

```
123.456
정수 부분 : 123456
소수점 위치 : 3 (소수점 이하 3자리)
저장 형태 : 123456 * 10^(-3)
```

## 리뷰

- 출력 부분은 알고 있는 내용이라 짧게 보며 제어 문자나 변환 문자도 훑으면서 진행했다
- 보수의 정확한 개념을 이해했다. 이전에는 보수가 무엇인지 보다는 2의 보수를 사용하고 어떻게 만드는 방법만 공부했다면 이번에 보수의 수학적 의미에 대해서 확실하게 학습했다
- 프로그래밍에서 실수의 오차가 일어나는 이유가 부동 소수점인 것은 알아도 연산 과정까지는 이해하지 못했으나 이번에 확실하게 이해했다
- 실수의 오차를 막기 위해 자주 사용하는 Decimal의 기본적인 구조에 대해서 공부했다

---

# 03 변수와 데이터 입력  
## 변수  
## 데이터 입력  

# 04 연산자  
## 산술 연산자, 관계 연산자, 논리 연산자  
## 그 외 유용한 연산자  

# 05 선택문  
## if문  
## if문 활용과 switch ~ case문  

# 06 반복문  
## while문, for문, do ~ while문  
## 반복문 활용  

# 07 함수  
## 함수의 작성과 사용  
## 여러 가지 함수 유형  

# 08 배열  
## 배열의 선언과 사용  
## 문자를 저장하는 배열  

# 09 포인터  
## 포인터의 기본 개념  
## 포인터 완전 정복을 위한 포인터 이해하기  

# 10 배열과 포인터  
## 배열과 포인터의 관계  
## 배열을 처리하는 함수  

# 11 문자  
## 아스키 코드 값과 문자 입출력 함수  
## 버퍼를 사용하는 입력 함수  

# 12 문자열  
## 문자열과 포인터  
## 문자열 연산 함수  

# 13 변수의 영역과 데이터 공유  
## 변수 사용 영역  
## 함수의 데이터 공유 방법  

# 14 다차원 배열과 포인터 배열  
## 다차원 배열  
## 포인터 배열  

# 15 응용 포인터  
## 이중 포인터와 배열 포인터  
## 함수 포인터와 void 포인터  

# 16 메모리 동적 할당  
## 동적 할당 함수  
## 동적 할당 저장 공간의 활용  

# 17 사용자 정의 자료형  
## 구조체  
## 구조체 활용, 공용체, 열거형  

# 18 파일 입출력  
## 파일 개방과 입출력  
## 다양한 파일 입출력 함수  

# 19 전처리와 분할 컴파일  
## 전처리 지시자  
## 분할 컴파일  

